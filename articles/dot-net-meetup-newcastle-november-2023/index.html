<!doctype html>
<html lang="en" class="h-100">
    <head>
        <meta charset="utf-8">
        <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=yes">
        <meta name="description" content="RoguePlanetoid"/>
        <!-- Twitter -->
        <meta name="twitter:card" content="summary_large_image"/>
        <meta name="twitter:site" content="@rogueplanetoid"/>
        <meta name="twitter:creator" content="@rogueplanetoid"/>
        <meta name="twitter:title" content="RoguePlanetoid"/>
        <meta name="twitter:description" content="Posts, Articles and Podcast"/>
        <meta name="twitter:image" content="https://www.rogueplanetoid.com/images/card.png"/>
        <meta name="twitter:image:alt" content="Posts, Articles and Podcast"/>
        <!-- /Twitter -->
        <!-- Open Graph -->
        <meta property="og:type" content="website"/>
        <meta property="og:title" content="RoguePlanetoid"/>
        <meta property="og:site_name" content="RoguePlanetoid">
        <meta property="og:description" content="Posts, Articles and Podcast"/>
        <meta property="og:image" content="https://www.rogueplanetoid.com/images/card.png"/>
        <meta property="og:image:width" content="1280"/>
        <meta property="og:image:height" content="630"/>
        <!-- /Open Graph -->
        <link rel="icon" href="../../favicon.ico"/>
        <link href="../../css/style.css" rel="stylesheet">
        <link href="../../bootstrap/css/bootstrap.min.css" rel="stylesheet">
        <title>RoguePlanetoid - Articles - Qudos .NET Meetup Newcastle - November 2023</title>
        <!-- Google tag (gtag.js) -->
        <script async src="https://www.googletagmanager.com/gtag/js?id=G-8038JPY7YN"></script>
        <script>
            window.dataLayer = window.dataLayer || [];
            function gtag(){dataLayer.push(arguments);}
            gtag('js', new Date());
            gtag('config', 'G-8038JPY7YN');
        </script>
    </head>
    <body class="d-flex flex-column h-100">
        <!-- Main -->
        <main>       
            <!-- Navigation -->	
            <nav class="navbar top navbar-light navbar-expand-md bg-brand">
                <div class="container-fluid">
                    <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#rogueplanetoid-navbar" aria-controls="rogueplanetoid-navbar" aria-expanded="false" aria-label="Toggle navigation">
                        <span class="navbar-toggler-icon"></span>
                    </button>
                    <a class="navbar-brand" href="../../">
                        <img src="../../images/header-articles.png" alt="RoguePlanetoid" height="25px">
                    </a>
                    <div id="rogueplanetoid-navbar" class="collapse navbar-collapse">
                        <ul class="navbar-nav">
                            <li class="nav-item">
                                <a class="nav-link text-articles" href="../../">Home</a>
                            </li>
                            <li class="nav-item">
                                <a class="nav-link text-articles" href="../../posts">Posts</a>
                            </li>
                            <li class="nav-item">
                                <a class="nav-link text-articles" href="../../articles">Articles</a>
                            </li>
                            <li class="nav-item">
                                <a class="nav-link btn btn-articles active" href="../dot-net-meetup-newcastle-november-2023/">Qudos .NET Meetup Newcastle - November 2023</a>
                            </li>
                            <li class="nav-item">
                                <a class="nav-link text-articles" href="../../podcast">Podcast</a>
                            </li>
                        </ul>
                    </div>
                    <a href="https://www.comentsys.com" target="_blank">
                        <img src="../../images/comentsys.png" alt="Comentsys" height="50px">
                    </a>
                </div>
            </nav>
            <!-- /Navigation -->     
            <!-- Section -->               
            <section class="text-center text-black container">
                <!-- Article -->
                <div class="text-start">
                    <article class="blog-post">
                        <h2 class="blog-post-title mb-1">Qudos .NET Meetup Newcastle - November 2023</h2>
                        <p class="blog-post-meta">22nd September 2023</p>                
                        <img src="../assets/qudos.png" class="img-fluid" alt="Qudos .NET Meetup Newcastle - November 2023"/>  
                        <h3>What is Windows App SDK? - Peter Bull</h3>
                        <h4>Native Windows App Platforms</h4>
                        <p>
                            History of Native Windows application platforms starts with the first versions of Windows released in the early 1980s where developers would have used the 
                            Windows API directly to create their applications that would be compiled to machine code that would then run natively on Windows.  In the late 1980s Microsoft 
                            introduced Visual Basic which was a rapid application platform including drag and drop user interface creation that made it quicker and easier for developers to 
                            build native applications on Windows. In mid 1990s Microsoft then introduced Microsoft Foundation Classes or MFC which was a C++ library that provided developers 
                            with a high-level abstraction and object-oriented wrapper of the Windows API to create native applications. By the early 2000s Microsoft introduced Windows Forms 
                            or WinForms with the release of the very first version of .NET which also included drag-and-drop user interface creation, but developers could also invoke native 
                            Windows API if needed.
                        </p>
                        <p>
                            In the mid-2000s Microsoft added WPF or Windows Presentation Foundation to the .NET Framework which introduced a new markup-based language called XAML or eXtensible 
                            Application Markup Language to create the user interface in ways that were not possible using Windows Forms. By the early 2010s Microsoft create WinRT which was 
                            designed to be a modern replacement for the Windows API and allowed for more modern applications to be created with .NET for desktop or mobile using XAML-based 
                            WinUI to provide the controls and styling. In the mid-2010s Microsoft expanded this idea with a brand-new application model known as UWP or Universal Windows 
                            Platform to create applications that would run on any device such as desktop, mobile, tablet and even Xbox or HoloLens that used Windows 10, this also later 
                            included support for WinUI 2 enabling new controls to be used in applications even in earlier versions of Windows 10 or to add new controls that were not yet 
                            part of the Windows Platform. By the early 2020s Microsoft introduced Windows App SDK which was the result of project reunion to combine the Universal Windows 
                            Platform with native Win32 desktop applications and provide a single set of Windows APIs for applications using later versions of Windows 10 to Windows 11 and 
                            using WinUI 3 to create applications using the latest Fluent Design Language from Microsoft.
                        </p>
                        <h4>Windows App SDK</h4>
                        <p>
                            Windows App SDK provides a unified set of APIs and tools to developers to create native Windows desktop applications that can be published to the Microsoft Store 
                            targeting Windows 10 1809 or later to every version of Windows 11. Windows App SDK updates are not tied to Windows Updates and there is a new version available 
                            every six months with the latest being version 1.4 and supports both the newer WinRT API along with the native Windows API. Windows App SDK is community driven 
                            with regular community standups to discuss new features or define the roadmap for future functionality such as InkCanvas which is a control I have been waiting 
                            for from Universal Windows Platform and will hopefully be coming in the next version of Windows App SDK 1.5. Windows App SDK is open-source and you can check it 
                            out at <a href="https://github.com/microsoft/WindowsAppSDK" target="_blank">github.com/microsoft/WindowsAppSDK</a>.
                        </p>
                        <p>
                            Developers can of course support Windows App SDK with their own packages such as my own which is <a href="https://www.nuget.org/packages/Comentsys.Toolkit.WindowsAppSdk" target="_blank">Comentsys.Toolkit.WindowsAppSDK</a> 
                            which adds some useful controls that can be used in applications and games such as Card to display a playing card, Dice which can be used to show a value on some dice, 
                            Piece which can be used to represent part of a game and Sector which can be used to display part of a circle or donut as needed. One of the controls can also display 
                            Assets using the .NET Standard based asset packs such as for Flags of the world in both square and rectangle, Chess and Mahjong for those pieces and tiles, and Flat, 
                            Shared and Contrast Fluent Emoji which allows you to use these assets designed by Microsoft in applications or games using Windows App SDK. 
                        </p>
                        <p>
                            Windows App SDK allows developers to use the latest versions of .NET including the latest functionality unlike Universal Windows Platform which is stuck on .NET Native 
                            which is essentially .NET Framework, .NET has improved performance with every recent release allowing for more performant native Windows applications, Windows App SDK 
                            using the latest .NET also means that developers can use the latest C# features in C# 12 unlike with Universal Windows Platform which is stuck on C# 7.3 and Windows App 
                            SDK can leverage any of the latest functionality or features such as AI integrations. You can find out more about the latest version of .NET at <a href="https://www.dot.net" target="_blank">dot.net</a>.
                        </p>
                        <p>
                            Getting started with Windows App SDK is simple, you just need to download and install Visual Studio for Windows and you can even use the Community edition if you want, 
                            if installing or modifying the installation of Visual Studio you will need to choose the .NET desktop development workload then select the Windows App SDK C# template 
                            from the installation details and then once installed you will be able to create a WinUI 3 in Desktop Project. To learn more about getting started with Windows App SDK 
                            from one of the many tutorials I have written for Windows App SDK at <a href="https://tutorialr.com/tutorials/winappsdk" target="_blank">tutorialr.com/tutorials/winappsdk</a>.
                        </p>
                        <h4>What is WinUI?</h4>
                        <p>
                            WinUI provides a user interface layer with modern controls that feature the latest Fluent Design Language used by Microsoft's own applications and Windows 11 itself. WinUI 2 
                            provides more up-to-date controls and functionality for existing Universal Windows Platform applications and WinUI 3 is the native user interface platform as part of the Windows 
                            App SDK, but it also provides the native desktop experience for .NET MAUI and the Uno Platform. WinUI 3 is also community driven for the roadmap and features along with recently 
                            having the source code for the latest release being provided which allowed for WinUI controls to be ported natively to Uno Platform and even Windows Presentation Foundation. 
                            You can check out WinUI 3 along with the source code for releases at <a href="https://github.com/microsoft/microsoft-ui-xaml" target="_blank">github.com/microsoft/microsoft-ui-xaml</a>.
                        </p>
                        <p>
                            WinUI supports basic input controls such as Button, Checkbox, ComboBox, RadioButton, Slider and ToggleSwitch and these controls can be used as-is to match those used in Windows 
                            or can be restyled to however you need them to look in your application. Collections can be displayed in a DataGrid for rows and columns in table, FlipView for a carousel-like 
                            view for one at a time, GridView for showing items in rows and columns, ItemsView which can use various layouts that you can even swap between, ListBox for a list of items and 
                            a TreeView to display nested items. WinUI supports flexible layouts such as Canvas for absolute positioning of elements, Expander for content that can be expanded, RelativePanel 
                            that use relationships between elements, SplitView for two content areas, StackPanel for vertical and horizontal layouts and ViewBox that can be used to scale elements as 
                            needed. WinUI supports many more controls such as CalendarView for selecting dates, Flyout for contextual information, WebView2 to host HTML content using the latest Chromium 
                            based Microsoft Edge, MenuBar for menu items, ParallaxView to provide a parallax view when scrolling - which in a previous version of this in Universal Windows Platform on 
                            Windows 10 I found a bug with that and got it fixed and finally there is a TabView for created tab-based user interfaces. Developers or anyone else can check out all the 
                            supported controls and more in WinUI along with other features such as motion and styles with the WinUI 3 Gallery Application which can be downloaded from the Microsoft Store, 
                            along with the Windows Community Toolkit which adds more controls and features such as RadialGauge to display values, Segmented control for settings and SettingsCard to create 
                            experiences like the settings in Windows 11 along with layouts such as WrapLayout, UniformGrid and DockPanel which can arrange elements to the top, left, bottom and right of 
                            each other.
                        </p>
                        <h4>Overview</h4>
                        <p>
                            Windows App SDK supports native application development on Windows from Windows 10 1809 to the latest versions of Windows 11, it is community driven for updates and 
                            functionality and allows developers to leverage the latest .NET features and C# language. Windows App SDK leverages WinUI 3 for modern controls using the Fluent Design 
                            Language along with support for the latest or existing Windows API and allows developers to create modern native Windows applications. You can download the slides and demo 
                            at <a href="https://github.com/RoguePlanetoid/whatiswindowsappsdk" target="_blank">github.com/RoguePlanetoid/whatiswindowsappsdk</a>.
                        </p>
                        <h3>Bare Bones .NET Core Identity in .NET 7 - David Apomah</h3>
                        <p>
                            If you're lucky someone has already added identity to a project, in their case they had Azure Identity B2C, but they wanted something a bit more bare bones. They have an API 
                            project along with a project for the models, you can view the Swagger for the default endpoints along with any that have been added. 
                        </p>
                        <p>
                            .NET Identity has JwtBearer as will be working with JWTs and then have SQL Server for the storage, need to have the relevant namespaces and database tables will need to be 
                            set up correctly. You can have application users and application roles and have application user roles. You need to specify the relationship between these to make sure that 
                            the database tables are setup correctly then have the identity context set up for .NET identity. You will specify how the models relate to each other and then can seed the 
                            data depending on what you need which is usually what you want the database to have initially. You can create the migrations which are created from the models and then can 
                            be used to apply the changes to the database and create it if it doesn't already exist using .NET migrations. This migration will create all the ASP.NET user tables that you 
                            would expect for the Identity tables for users and roles.
                        </p>
                        <p>
                            It is possible to extend the identity object as needed when creating users in the code, you can provide the validation for the password and then can create the user. You can 
                            also implement anything that your business logic requires.  You can also have features like email confirmation token to check for a valid email address, the token generation 
                            is done with an existing user manager class and often methods are named exactly what you need them to do such as generating or validating this token. It can be very 
                            straightforward once you have your business processes mapped to do things like generate 2FA tokens and validate these and once fully logged in can generate a JWT which you 
                            could inspect at jwt.io to see the constituent parts. You could use this with Blazor or anything as it is just an API you can you use it with anything. With Swagger you can 
                            specify the authorisation scheme to use JWT to test the API to pass in the tokens or identity implementation you need to.
                        </p>
                        <h3>Building an LCARS dashboard with Minimal APIs and Blazor in .NET 8 - Rob King</h3>
                        <p>
                            They had an old dashboard they had written at Bede Gaming and have updated to look like LCARs which is the Library Computer Access Retrieval System in Star Trek. 
                            They created this Dashboard to see status of things in Octopus Deploy, GitHub and TeamCity.
                        </p>
                        <h4>Minimal APIs</h4>
                        <p>
                            What are minimal APIs? They are different from a traditional controller which can have a lot of code whereas a minimal API can have a single line and just a few lines for 
                            the whole application. Often people say “that's great as a demo but it doesn't represent the real world” but you can create endpoints that take parameters with the values in 
                            the route for a get for example or for a post it will expect a body but if you add more endpoints then can have too many and be difficult to understand and break down. 
                            Pros of them are a low barrier to entry with no boilerplate code and routing / logic is in one place and are faster that controllers. Cons of them is larger APIs will 
                            become cumbersome if not structured correctly. You could define some endpoints for GitHub where you can have the specific mappings for GitHub to there and it will be the 
                            actual objects and no abstraction of these but you can also have an IResult which can be Not Found or Ok with the value, and can use either depending on what you need. 
                            You also need to consider the structure such as Endpoints, Models, Reponses - group them by their concern themselves, by the domain such as TeamCity, Octopus Deploy etc 
                            and can use the pattern of microservices within one app so can easily add or remove functionality and don't have to regression test anything existing. You can also move 
                            the definition of the endpoints and the registration of the services and any other dependencies as an interface so can have a common mapping for these. You can then search 
                            the application for the adding of services and register these and do this for the endpoints as well and can register the defined types that implement the interface but that 
                            are not abstract or interfaces. You can create any new classes or implementations without having to do any other work and setup the services and endpoints as needed using 
                            Dependency Injection.
                        </p>
                        <h4>Blazor</h4>
                        <p>
                            Blazor is an open-source web framework part of ASP.NET Core and allows developers to create interactive user interfaces using C# instead of JavaScript. This allows developers 
                            familiar with the .NET ecosystem and allows them to use their existing C# skills to build web apps. Blazor Server is where application code executes on the server and user 
                            interface is updated in client-side in real-time the UI is rendered in the browser using SignalR to communicate with the server. When you create a Blazor Web App you can pick 
                            Server, WebAssembly or Auto (Server and WebAssembly). Static Server Rendering is where static HTML is sent to browser although users cannot interact with the content but is 
                            useful for home pages, blogs and other static content. Blazor WebAssembly is a technology run on modern browsers without needing any plugs or extensions unlike Flash or 
                            Silverlight and provides a set of familiar concepts such as components and data binding like those used in JavaScript frameworks such as Angular and React. Blazor server 
                            is for smaller payload and fast initial loadtime with direct access to server for network resources and support browsers that don't support Web Assembly and older devices. 
                            Blazor Web Assembly allows you to run apps offline once download and can be served statically with static site hosting and no server is required to execute server-side code 
                            and can offload processing on the client. Do you have to pick one or the other? You don't any more as there is an Auto mode as when a component is first rendered will be a 
                            server component and download WebAssembly in the background and then will be used locally once that has happened, with this app you will get a client app that will be 
                            anything that runs locally such as in the example with the Counter feature to create a countdown. You can check out the LCAS Dashboard at <a href="https://github.com/gcsuk/LCARS">github.com/gcsuk/LCARS</a>.
                        </p>                        
                    </article>
                </div>
                <!-- /Article -->
            </section>
            <!-- /Section -->     
        </main>
        <!-- /Main -->
        <!-- Footer -->
        <footer class="footer mt-auto">
            <div class="steps steps-articles"></div>  
            <nav class="navbar bottom navbar-light p-2 bg-articles">
                <a href="../../"><img src="../../images/footer.png" alt="RoguePlanetoid" height="20px"></a>
                <a href="https://www.twitter.com/rogueplanetoid" target="_blank"><img src="../../images/twitter.png" height="45px" alt="@RoguePlanetoid"></a>
            </nav>
        </footer>
        <!-- /Footer -->
        <!-- Scripts -->
        <script src="../../bootstrap/js/bootstrap.bundle.min.js"></script>
        <!-- /Scripts-->
    </body>
</html>